#!/bin/bash
# bashreduce: mapreduce in bash
# erik@fawx.com

usage() {
	echo "Usage: $1 --hosts|-h '<host>[ <host>][...]' " \
		"[--column|-c <column>]" >&2
	echo "       [--map|-m <map>] [--reduce|-r <reduce>] [--mirror]" >&2
	echo "       [--input|-i <input>] [--output <output>]" >&2
	echo "       [--tmp <tmp>] [-S <sort-mem-MB>] [--help]" >&2
	if [ -n "$2" ] ; then
		echo "  --hosts  hosts to use; can repeat hosts for multiple cores" >&2
		echo "           (defaults to contents of /etc/br.hosts)" >&2
		echo "  --column column to use during partitioning (defaults to 1)" >&2
		echo "  --map    map program (defaults to cat)" >&2
		echo "  --reduce reduce program" >&2
		echo "  --mirror assume the input data is mirrored on each node" >&2
		echo "  --input  input directory; to use a file, redirect stdin" >&2
		echo "           (defaults to stdin)" >&2
		echo "  --output output directory; to use a file, redirect stdout" >&2
		echo "           (defaults to stdin)" >&2
		echo "  --tmp    tmp directory (defaults to /tmp)" >&2
		echo "  -S       memory to use for sort (defaults to 256M)" >&2
		echo "  --help   this help message" >&2
	fi
	exit 2
}

# Defaults
hosts=
column=1
map=cat
reduce=
mirror=false
input=
output=
tmp=/tmp
sort_mem=256M

# TODO: Allow --thing=stuff syntax, too
program=$(basename $0)
set -- $(getopt --unquoted --name $program --options "h:c:m:r:Mi:o:t:S:" \
	--longoptions \
	"hosts:,column:,map:,reduce:,mirror,input:,output:,tmp:,help" \
	-- "$@") \
	|| usage $program
[ $# -eq 0 ] && usage $program
last=
while [ $# -gt 0 ] ; do
	case "$1" in
		-h|--hosts) last=h; hosts=$2; shift 2;;
		-c|--column) last=c; column=$2; shift 2;;
		-m|--map) last=m; map=$2; shift 2;;
		-r|--reduce) last=r; reduce=$2; shift 2;;
		-M|--mirror) last=M; mirror=true; shift;;
		-i|--input) last=i; input=$2; shift 2;;
		-o|--output) last=o; output=$2; shift 2;;
		-t|--tmp) last=t; tmp=$2; shift 2;;
		-S) last=S; sort_mem=$2; shift 2;;
		--help) usage $program MOAR;;
		--) unset last; shift;;
		*) if [ "$last" == h ]; then hosts="$hosts $1"; shift;
			else usage $program; fi;;
	esac
done 
unset last

# If --hosts wasn't given, try /etc/br.hosts
if [ -z "$hosts" ]; then
	if [ -e /etc/br.hosts ]; then
		hosts=$(cat /etc/br.hosts)
	else
		echo "$program: must specify --hosts or provide /etc/br.hosts"
		usage $program
	fi
fi

# if we have a reduce, add the pipe explicitly
[ -n "$reduce" ] && reduce="| $reduce 2>/dev/null"

# okay let's get started!	first we need a name for our job
jobid="$(uuidgen)"
jobpath="$tmp/br_job_$jobid"
nodepath="$tmp/br_node_$jobid"
mkdir -p $jobpath/{in,out}

# now, for each host, set up in and out fifos (and a netcat for each), and ssh to each host to set up workers listening on netcat

port_in=8192
port_out=$(($port_in + 1))
host_idx=0
out_files=

for host in $hosts; do
  # our named pipes
  mkfifo $jobpath/{in,out}/$host_idx
  # lets get the pid of our listener
  ssh -n $host "mkdir -p $nodepath"
  pid=$(ssh -n $host "nc -l -p $port_out >$nodepath/in_$host_idx 2>/dev/null </dev/null & jobs -l" | awk {'print $2'})
  ssh $host -n "tail -s0.1 -f --pid=$pid $nodepath/in_$host_idx 2>/dev/null </dev/null | LC_ALL='$LC_ALL' sort -S$sort_mem -T$tmp_dir -k$mapcolumn,$mapcolumn 2>/dev/null $reduce | nc -q0 -l -p $port_in >&/dev/null &"
  # our local forwarders
  nc $host $port_in >$jobpath/in/$host_idx &
  nc -q0 $host $port_out <$jobpath/out/$host_idx &
  # our vars
  out_files="$out_files $jobpath/out/$host_idx"
  port_in=$(($port_in + 2))
  port_out=$(($port_in + 1))
  host_idx=$(($host_idx + 1))
done

# okay, time to map
if which brp >/dev/null; then
	BRP=brp
elif [ -f brutils/brp >/dev/null ]; then
	BRP=brutils/brp
fi
if [ -n "$BRP" ]; then
	eval "${input:+pv $input |} $BRP - $(($column - 1)) $out_files"
else
  # use awk if we don't have brp
  # we're taking advantage of a special property that awk leaves its file handles open until its done
  # i think this is universal
  # we're also sending a zero length string to all the handles at the end, in case some pipe got no love
  eval "${input:+pv $input |} awk '{
      srand(\$$mapcolumn);
      print \$0 >>\"$jobpath/out/\"int(rand() * $host_idx);
    }
    END {
      for (i = 0; i != $host_idx; ++i)
        printf \"\" >>\"$jobpath/out/\"i;
    }'"
fi

# save it somewhere
if which brm >/dev/null; then
	BRM=brm
elif [ -f brutils/brm >/dev/null ]; then
	BRP=brutils/brm
fi
if [ -n "$BRM" ]; then
	eval "$BRM- $(($column - 1)) `find $jobpath/in/ -type p | xargs` ${output:+| pv >$output}"
else
  # use sort -m if we don't have brm
  # sort -m creates tmp files if too many input files are specified
  # brm doesn't do this
  eval "sort -k$mapcolumn,$mapcolumn -m $jobpath/in/* ${output:+| pv >$output}"
fi

# finally, clean up after ourselves
rm -rf $jobpath
for host in $hosts; do
  ssh $host "rm -rf $nodepath"
done

# TODO: is there a safe way to kill subprocesses upon fail?
# this seems to work: /bin/kill -- -$$
